{
    "cp_wacky_snippet": {
        "prefix": "cpt",
        "body": [
            "#include \"bits/stdc++.h\"",
            "using namespace std;",
            "",
            "#define int int64_t",
            "#define endl '\\n'",
            "#define all(x) x.begin(), x.end()",
            "#define sz(x)  (int)x.size()",
            "",
            "const int mod = 1e9 + 7, INF = 1e18L + 5, N = 2e5 + 5;",
            "const string yes = \"YES\", no = \"NO\";",
            "namespace debug{",
            "    template <typename A, typename B>ostream &operator<<(ostream &os, const pair<A, B> &p){return os << '(' << p.first << \", \" << p.second << ')';}",
            "    template <typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type>ostream &operator<<(ostream &os, const T_container &v){    os << '{';string sep;for (const T &x : v)os << sep << x, sep = \", \";return os << '}';}",
            "    void dbg_out() { cerr << endl; }",
            "    template <typename Head, typename... Tail>",
            "    void dbg_out(Head H, Tail... T){cerr << ' ' << H; dbg_out(T...);}",
            "} // namespace debug",
            "using namespace debug;",
            "",
            "void scan() {} template <typename Head, typename ...Tail> void scan(Head &H, Tail &...T) { cin >> H; scan(T...); }",
            "void print() { cout << \"\\n\"; } template <typename Head> void print(const Head &H) { cout << H << \"\\n\"; } template <typename Head, typename ...Tail> void print(const Head &H, const Tail &...T) { cout << H << \" \"; print(T...); }",
            "#define ini(_n)  int _n;cin>>_n;",
            "#define sni(_s)  string _s;cin>>_s;",
            "#define input(vec,s,n) vector<int> vec(s+n);for(int i=s;i<s+n;i++){cin>>vec[i];}",
            "#define output(vec,s,n)  for(int i=s;i<s+n;i++){ cout<<vec[i]<<\" \";} cout<<endl",
            "#define lb(c, x) distance((c).begin(), lower_bound(all(c), (x)))", //gives index;
            "#define ub(c, x) distance((c).begin(), upper_bound(all(c), (x)))",
            "template <typename T> using vv = vector<vector<T>>;",
            "template <typename T> using mxpq = priority_queue<T>;",
            "template <typename T> using mnpq = priority_queue<T, vector<T>, greater<T>>;",
            "#define setbits(x)  __builtin_popcountll(x) // returns number of 1-bits of x",
            "#define trailing0(x) __builtin_ctzll(x) //returns num of trailing 0-bits of x",
            "#define leading0(x) __builtin_clzll(x) //returns num of leading 0-bits of x",
            "#define firstbitpos(x) __builtin_ffsll(x) //returns 1 + indexOf(least significant 1-bit)",
            "#define binary(n) bitset<32>(n)",
            "#define seal(n,m) (n%m!=0)?(n/m+1):(n/m)",
            "",
            "void extendgcd(int a, int b, int *v){if (b == 0){v[0] = 1; v[1] = 0;v[2] = a;return;}extendgcd(b, a % b, v);int x = v[1];v[1] = v[0] - v[1] * (a / b);v[0] = x;return;}",
            "int mminv(int a, int b){int arr[3];extendgcd(a, b, arr);return (arr[0]%b+b)%b;} // if b is prime just do mpow(a,b-2,b)",
            "template <class T> vector<T> divisor(T x){ vector<T> ans; for (T i = 1; i * i <= x; i++) if (x % i == 0) { ans.push_back(i); if (i * i != x) ans.push_back(x / i);}return ans;}",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"\\033[0;33m\" << __func__ << \" : \" << __LINE__ << \" \" << \"(\" << #__VA_ARGS__ << \") : \",dbg_out(__VA_ARGS__),cerr << \"\\033[0m\";",
            "#else",
            "#define dbg(...) 2529;",
            "#endif",
            "",
            "typedef vector<int> vi;",
            "typedef pair<int,int> pi;",
            "void solve()",
            "{",
            "    $0",
            "}",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false);",
            "    cin.tie(nullptr);",
            "#ifdef Sieve",
            "    Eratosthenes(N);",
            "#endif",
            "#ifdef NCR",
            "    gen_factorial(N);",
            "#endif",
            "    int T= 1;",
            "    ${1:cin >> T};",
            "    for (int test = 1; test <= T; ++test)",
            "    {",
            "        solve();",
            "    }",
            "    return 0;",
            "}"
        ],
        "description": "cp_wacky_snippet"
    },
    "large exponentiation":{
        "prefix": "lmul",
			"body": [
				" ",
				"/* large exponential if A , B and M(mod like 1e18+7) are in the range of 1e18 */",
				"int lMul(int a, int b, int M=1e18+7);",
				"// TC- (log(n))*(log(n))",
				"int largeExpo(int A, int B, int M=1e18+7){",
				"\tint ans=1;",
				"\twhile(B){",
				"\t\tif(B&1){",
				"\t\t\t// ans=(ans*1LL*A)%M          // results in overflow",
				"\t\t\tans=lMul(ans,A);",
				"\t\t}",
				"\t\tA=lMul(A,A);",
				"\t\tB>>=1;",
				"\t}",
				"\treturn ans;",
				"}",
				"int lMul(int a, int b, int M=1e18+7){",
				"\tint ans=0;",
				"\twhile(b){",
				"\t\tif(b&1){",
				"\t\t\tans= (ans+a)%M;",
				"\t\t}",
				"\t\ta = (a+a)%M;",
				"\t\tb>>=1;",
				"\t}",
				"\treturn ans;",
				"}",
				"// if b is large",
				"// a^b mod m = a^(b mod etf(m)) mod m\n",
			],
			"description": "large exponentiation used when exponent is large"
    },
    "policy based data structure": {
        "prefix": "pbdss",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
            "//Note: less<int> is bool cmp, use greater<int> for descending order, less_equal<int> for multiset",
            "//eg: ",
            "//pbds A;  //declaration",
            "//A.find_by_order(val); //return number of integer strictly less than val in the set  (in log(n))",
            "//A,order_by_key(k);  //gives iterator to the kth smallest element (k starts from 0) in log(n)\n",
        ],
        "description": "policy based data structure similar to set but with extra functionality"
    },
    "Bare minimum C++ program": {
        "prefix": "mint",
        "body": [
            "template <typename T>",
            "T inverse(T a, T m)",
            "{",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0)",
            "\t{",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "template <typename T>",
            "class Modular",
            "{",
            "public:",
            "  using Type = typename decay<decltype(T::value)>::type;",
            "",
            "  constexpr Modular() : value() {}",
            "  template <typename U>",
            "  Modular(const U &x)",
            "  {",
            "    value = normalize(x);",
            "  }",
            "",
            "  template <typename U>",
            "  static Type normalize(const U &x)",
            "  {",
            "    Type v;",
            "    if (-mod() <= x && x < mod())",
            "      v = static_cast<Type>(x);",
            "    else",
            "      v = static_cast<Type>(x % mod());",
            "    if (v < 0)",
            "      v += mod();",
            "    return v;",
            "  }",
            "",
            "  const Type &operator()() const { return value; }",
            "  template <typename U>",
            "  explicit operator U() const { return static_cast<U>(value); }",
            "  constexpr static Type mod() { return T::value; }",
            "",
            "  Modular &operator+=(const Modular &other)",
            "  {",
            "    if ((value += other.value) >= mod())",
            "      value -= mod();",
            "    return *this;",
            "  }",
            "  Modular &operator-=(const Modular &other)",
            "  {",
            "    if ((value -= other.value) < 0)",
            "      value += mod();",
            "    return *this;",
            "  }",
            "  template <typename U>",
            "  Modular &operator+=(const U &other) { return *this += Modular(other); }",
            "  template <typename U>",
            "  Modular &operator-=(const U &other) { return *this -= Modular(other); }",
            "  Modular &operator++() { return *this += 1; }",
            "  Modular &operator--() { return *this -= 1; }",
            "  Modular operator++(int32_t)",
            "  {",
            "    Modular result(*this);",
            "    *this += 1;",
            "    return result;",
            "  }",
            "  Modular operator--(int32_t)",
            "  {",
            "    Modular result(*this);",
            "    *this -= 1;",
            "    return result;",
            "  }",
            "  Modular operator-() const { return Modular(-value); }",
            "",
            "  template <typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, int32_t>::value, Modular>::type &operator*=(const Modular &rhs)",
            "  {",
            "#ifdef _WIN32",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
            "    asm(",
            "        \"divl %4; \\n\\t\"",
            "        : \"=a\"(d), \"=d\"(m)",
            "        : \"d\"(xh), \"a\"(xl), \"r\"(mod()));",
            "    value = m;",
            "#else",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "#endif",
            "    return *this;",
            "  }",
            "  template <typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs)",
            "  {",
            "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
            "    value = normalize(value * rhs.value - q * mod());",
            "    return *this;",
            "  }",
            "  template <typename U = T>",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs)",
            "  {",
            "    value = normalize(value * rhs.value);",
            "    return *this;",
            "  }",
            "",
            "  Modular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "  template <typename U>",
            "  friend const Modular<U> &abs(const Modular<U> &v) { return v; }",
            "",
            "  template <typename U>",
            "  friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "  template <typename U>",
            "  friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "  template <typename U>",
            "  friend std::istream &operator>>(std::istream &stream, Modular<U> &number);",
            "",
            "private:",
            "  Type value;",
            "};",
            "",
            "template <typename T>",
            "bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
            "template <typename T, typename U>",
            "bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template <typename T, typename U>",
            "bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
            "",
            "template <typename T>",
            "bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T>",
            "bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
            "",
            "template <typename T>",
            "Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template <typename T, typename U>",
            "Modular<T> power(const Modular<T> &a, const U &b)",
            "{",
            "  assert(b >= 0);",
            "  Modular<T> x = a, res = 1;",
            "  U p = b;",
            "  while (p > 0)",
            "  {",
            "    if (p & 1)",
            "      res *= x;",
            "    x *= x;",
            "    p >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "template <typename T>",
            "bool IsZero(const Modular<T> &number)",
            "{",
            "  return number() == 0;",
            "}",
            "",
            "template <typename T>",
            "string to_string(const Modular<T> &number)",
            "{",
            "  return to_string(number());",
            "}",
            "",
            "template <typename T>",
            "std::ostream &operator<<(std::ostream &stream, const Modular<T> &number)",
            "{",
            "  return stream << number();",
            "}",
            "",
            "template <typename T>",
            "std::istream &operator>>(std::istream &stream, Modular<T> &number)",
            "{",
            "  typename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "  stream >> x;",
            "  number.value = Modular<T>::normalize(x);",
            "  return stream;",
            "}",
            "",
            "/*",
            "using ModType = int32_t;",
            "",
            "struct VarMod { static ModType value; };",
            "ModType VarMod::value;",
            "ModType& md = VarMod::value;",
            "using Mint = Modular<VarMod>;",
            "*/",
            "",
            "//constexpr int32_t md = 998244353;",
            "constexpr int32_t md = 1000000007;",
            "using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
        ],
        "description": "modular arithmatic class "
    },
    "BFS template": {
        "prefix": "bfs",
        "body": [
            "auto bfs = [&](const vector<int>&source , vector<int>&d , vector<int>&p)",
            "{",
            "    d.assign(n + 1,0);",
            "    p.assign(n + 1,0);",
            "    vector<bool> used(n + 1, 0);",
            "    queue<int> q;",
            "    for(auto &ss : source){",
            "        q.push(ss);",
            "        used[ss] = true;",
            "    }",
            "    while (!q.empty())",
            "    {",
            "        int v = q.front();",
            "        q.pop();",
            "        for (auto u : g[v])",
            "        {",
            "            if (!used[u])",
            "            {",
            "                used[u] = true;",
            "                q.push(u);",
            "                d[u] = d[v] + 1;",
            "                p[u] = v;",
            "            }",
            "        }",
            "    }",
            "};",
            "${1:vector<int>d,par;",
            "bfs(${2:}, d, par);"
        ],
        "description": "bfs template"
    },
    "Cobinatorics- ncr function": {
        "prefix": "ncr",
        "body": [
            "vector<Mint> fact(1, 1);",
            "vector<Mint> inv_fact(1, 1);",
            "",
            "Mint ncr(int n, int k) {",
            "\tif (k < 0 || k > n) {",
            "\t\treturn 0;",
            "\t}",
            "\twhile ((int) fact.size() < n + 1) {",
            "\t\tfact.push_back(fact.back() * (int) fact.size());",
            "\t\tinv_fact.push_back(1 / fact.back());",
            "\t}",
            "\treturn fact[n] * inv_fact[k] * inv_fact[n - k];",
            "}",
        ],
        "description": "ncr function"
    },
    "binary_exponentiation": {
        "prefix": "exp",
        "body": [
            "int exp(int x, int y, int M = 0) {",
            "  int v = 1;",
            "  if (M > int(0)) {x = x % M; while (y > 0) {if (y & 1)v = (v * x) % M; y = y >> 1; x = (x * x) % M;} return v;}",
            "  else {while (y > 0) {if (y & 1)v = v * x; y = y >> 1; x = x * x;} return v;}",
            "}"
        ],
        "description": "binary_exponentiation"
    },
    "generates a sieve in a global array, each element stores largest prime factor of that number": {
        "prefix": "primemethods",
        "body": [
            "",
            "",
            "// this new sieve has been verified on",
            "// https://www.codechef.com/viewsolution/28092496",
            "// where the TL was extremely tight",
            "class Multiplicative",
            "{",
            "// This is the definition for PHI",
            "#define fn_prime_values(prime) (prime - 1)",
            "#define fn_non_coprime(num, prime) (fn[num] * prime)",
            "public:",
            "    int size;",
            "    vector<int> fn;",
            "    vector<int> primes;",
            "    vector<int> lowest_prime_factor;",
            "",
            "    Multiplicative(int size)",
            "    {",
            "        size = size;",
            "        lowest_prime_factor = vector<int>(size, 0);",
            "        fn = vector<int>(size, 0);",
            "        // https://stackoverflow.com/questions/34260399",
            "        // linear sieve",
            "        for (int i = 2; i < size; i++)",
            "            lowest_prime_factor[i] = i;",
            "        // put any specific initialization code here like",
            "        // multiplicativeFn[1] = 1;",
            "        for (int i = 2; i < size; i++)",
            "        {",
            "            if (lowest_prime_factor[i] == i)",
            "            {",
            "                fn[i] = fn_prime_values(i);",
            "                primes.push_back(i);",
            "            }",
            "",
            "            for (auto p : primes)",
            "            {",
            "                int ith_multiple = i * p;",
            "                if (ith_multiple >= size)",
            "                    break;",
            "",
            "                lowest_prime_factor[ith_multiple] =",
            "                    min(lowest_prime_factor[i], p);",
            "",
            "                if (i % p) // i and current_prime are coprime -> phi is multiplicative in this case",
            "                {",
            "                    fn[ith_multiple] = fn[i] * fn[p]; // (current_prime - 1) == phi[current_prime]",
            "                }",
            "                else",
            "                {",
            "                    fn[ith_multiple] = fn_non_coprime(i, p); // based on phi(p^(k+1)) / phi(p^k) == p",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "    }",
            "    /**Usage*/",
            "    // auto MP = Multiplicative(N);",
            "    // MP.primes",
            "    // MP.lowest_prime_factor",
            "    // MP.fn",
            "};",
            "",
            ""
        ],
        "description": "generates a sieve in a global array, each element stores largest prime factor of that number"
    },
    "split string": {
        "prefix": "splitstr",
        "body": [
            "vs splitstr(string s, char delim = ' '){",
            "    stringstream inputWay(s);",
            "    string dump;",
            "    vs ans;",
            "    while(getline(inputWay, dump, delim)){",
            "     ans.push_back(dump);",
            "    }",
            "    return ans;",
            "}"
        ]
    },
    "Get Divisors": {
        "prefix": "divisor",
        "body": [
            "template<typename T>",
            "std::vector<T> divisors(T n) {",
            "   std::vector<T> divisors;",
            "   for (int i = 1; (T) i * i <= n; i++) {",
            "       if (n % i == 0) {",
            "           divisors.push_back(i);",
            "           if (i != n / i) {",
            "               divisors.push_back(n / i);",
            "           }",
            "       }",
            "   }",
            "   return divisors;",
            "}"
        ],
        "description": "Get Divisors"
    },
    "Suffix_quick": {
        "prefix": "suff",
        "body": [
            "vector<int> suf(n);",
            "suf[n - 1] = a[n - 1];",
            "for (int i = n - 2; i >= 0; i--)",
            "{",
            "   suf[i] = a[i] + suf[i + 1];",
            "}"
        ],
        "description": "Suffix_quick"
    },
    "Prefix_quick": {
        "prefix": "pref",
        "body": [
            "vector<int> pref(n);",
            " pref[0] = a[0];",
            " for (int i = 1; i < n; i++)",
            " {",
            "     pref[i] = a[i] + pref[i - 1];",
            " }"
        ],
        "description": "Prefix_quick"
    },
    "GridInput": {
        "prefix": "grid",
        "body": [
            "vector<vector<int>> g(n, vector<int>(m));",
            " for (int i = 0; i < n; i++)",
            "    {",
            "        for (int j = 0; j < m; j++)",
            "        {",
            "            cin >> g[i][j];",
            "        }",
            "    }"
        ],
        "description": "GridInput"
    },
    "debugger_tourist": {
        "prefix": "tdebug",
        "body": [
            "string to_string(string s)",
            "{",
            "    return '\"' + s + '\"';",
            "}",
            "string to_string(const char *s)",
            "{",
            "    return to_string((string)s);",
            "}",
            "string to_string(bool b)",
            "{",
            "    return (b ? \"true\" : \"false\");",
            "}",
            "template <typename A, typename B>",
            "string to_string(pair<A, B> p)",
            "{",
            "    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";",
            "}",
            "template <typename A>",
            "string to_string(A v)",
            "{",
            "    bool first = true;",
            "    string res = \"{\";",
            "    for (const auto &x : v)",
            "    {",
            "        if (!first)",
            "        {",
            "            res += \", \";",
            "        }",
            "        first = false;",
            "        res += to_string(x);",
            "    }",
            "    res += \"}\";",
            "    return res;",
            "}",
            "void debug_out() { cerr << endl; }",
            "template <typename Head, typename... Tail>",
            "void debug_out(Head H, Tail... T)",
            "{",
            "    cerr << \" \" << to_string(H);",
            "    debug_out(T...);",
            "}",
            "#ifndef ONLINE_JUDGE",
            "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)",
            "#else",
            "#define debug(...) 42",
            "#endif"
        ],
        "description": "debugger_tourist"
    },
    "GRID dfs": {
        "prefix": "grid_dfs",
        "body": [
            "vector<vector<bool>> vis(n, vector<bool>(m, false));",
            "auto possible = [&](int u, int v)",
            "{",
            "    return u >= 0 && u < n && v >= 0 && v < m && (g[u][v] == 1 && !vis[u][v]);",
            "};",
            "function<void(int, int)> grid_dfs = [&](int u, int v)",
            "{",
            "    vis[u][v] = true;",
            "    // static int dr[4] = {-1, 0, 1, 0};",
            "    // static int dc[4] = {0, -1, 0, 1};",
            "    static int dr[8] = {-1, -1, -1, 0, 0, 1, 1, 1};",
            "    static int dc[8] = {-1, 0, 1, -1, 1, -1, 0, 1};",
            "    for (int k = 0; k < 8; k++)",
            "    {",
            "        if (possible(u + dr[k], v + dc[k])){",
            "            grid_dfs(u + dr[k], v + dc[k]);",
            "        }",
            "    }",
            "};",
            "${1:grid_dfs($2,$3);}",
            "$0"
        ],
        "description": "grid dfs"
    },
    "GRID bfs": {
        "prefix": "grid_bfs",
        "body": [
            "// static int dr[4] = {-1, 0, 1, 0};",
            "// static int dc[4] = {0, -1, 0, 1};",
            "static int dr[8] = {-1, -1, -1, 0, 0, 1, 1, 1};",
            "static int dc[8] = {-1, 0, 1, -1, 1, -1, 0, 1};",
            "",
            "auto e = [&] (int r, int c) {",
            "    return 0 <= r && r < n && 0 <= c && c < m;  ",
            "};",
            "auto grid_bfs = [&] (const vector<pair<int, int>> &source, vector<vector<int>> &d) {",
            "    d.assign(n, vector<int>(m, inf));",
            "    queue<pair<int, int>> q;",
            "    for (auto &p : source) {",
            "        int r = p.first;",
            "        int c = p.second;",
            "        q.emplace(r, c);",
            "        d[r][c] = 0;    ",
            "    }",
            "    while(!q.empty()) {",
            "        int r = q.front().first;",
            "        int c = q.front().second;",
            "        q.pop();   ",
            "        for(int dir = 0; dir < 8; dir++) {",
            "            int nr = r + dr[dir], nc = c  + dc[dir];",
            "            if(e(nr, nc) && d[r][c] + 1 < d[nr][nc]) {",
            "                q.emplace(nr, nc);",
            "                d[nr][nc] = d[r][c] + 1;",
            "            }",
            "        }    ",
            "    }",
            "};",
            "${1:vector<vector<int>> d;",
            "grid_bfs({{0, 0\\}\\}, d);}",
            "$0"
        ],
        "description": "grid bfs"
    },
    "getUnique": {
        "prefix": "unique",
        "body": [
            "#define getunique(v) sort(v.begin(), v.end()); v.erase(unique(v.begin(), v.end()), v.end());"
        ],
        "description": "getUnique"
    },
    "N_Size_ArrayInput": {
        "prefix": "arrayinput",
        "body": [
            "int n;",
            "cin >> n;",
            "vector<int> a(n);",
            "for (int i = 0; i < n; i++)",
            "{",
            "    cin >> a[i];",
            "}",
            "$0"
        ],
        "description": "N_Size_ArrayInput"
    },
    "Sorting Arrays through vector of pairs": {
        "prefix": "pairsort",
        "body": [
            "void pairsort(vector<int> &a, vector<int> &b, int n)",
            "{",
            "    vector<pair<int, int>> sortit(n);",
            "    for (int i = 0; i < n; i++)",
            "    {",
            "        sortit[i].first = a[i];",
            "        sortit[i].second = b[i];",
            "    }",
            "    sort(all(sortit));",
            "    for (int i = 0; i < n; i++)",
            "    {",
            "        a[i] = sortit[i].first;",
            "        b[i] = sortit[i].second;",
            "    }",
            "}"
        ],
        "description": "Sorting Arrays through vector of pairs"
    },
    "Debugger for c++": {
        "prefix": "dbg",
        "body": [
            "template <typename A, typename B>ostream &operator<<(ostream &os, const pair<A, B> &p){return os << '(' << p.first << \", \" << p.second << ')';}",
            "template <typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type>ostream &operator<<(ostream &os, const T_container &v){    os << '{';string sep;for (const T &x : v)os << sep << x, sep = \", \";return os << '}';}",
            "",
            "void dbg_out() { cerr << endl; }",
            "template <typename Head, typename... Tail>",
            "void dbg_out(Head H, Tail... T){cerr << ' ' << H; dbg_out(T...);}",
            "",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "#else",
            "#define dbg(...)",
            "#endif",
            ""
        ],
        "description": "Debugger for c++"
    },
    "DFS for grids": {
        "prefix": "griddfs",
        "body": [
            "vector<vector<bool>> vis(n, vector<bool>(m, false));",
            "auto possible = [&](int u, int v)",
            "{",
            "    return u >= 0 && u < n && v >= 0 && v < m && (g[u][v] == 1 && !vis[u][v]);",
            "};",
            "function<void(int, int)> grid_dfs = [&](int u, int v)",
            "{",
            "    vis[u][v] = true;",
            "",
            "    static int R[8] = {-1, -1, -1, 0, 0, 1, 1, 1};",
            "    static int C[8] = {-1, 0, 1, -1, 1, -1, 0, 1};",
            "",
            "    for (int k = 0; k < 8; k++)",
            "    {",
            "        if (possible(u + R[k], v + C[k]))",
            "              grid_dfs(u + R[k], v + C[k]);",
            "    }",
            "};"
        ],
        "description": "DFS for grids"
    },
    "depthFirstSearch": {
        "prefix": "dfs",
        "body": [
            "vector<bool> vis(n + 1);",
            "function<void(int)> dfs = [&](int u) {",
            "    vis[u] = true;",
            "    ",
            "    for(auto& v : g[u]) {",
            "        if(vis[v]) continue;",
            "        dfs(v);",
            "    }    ",
            "};",
            "dfs(1);"
        ],
        "description": "depthFirstSearch"
    },
    "Disjoint set Union": {
        "prefix": "dsu",
        "body": [
            "int parent[N];",
            "int siz[N];",
            "// int rnk[N];",
            "",
            "void make_set(int v){",
            "\tparent[v]=v;",
            "\tsiz[v] = 1;  //when use siz",
            "\t// rnk[v]=0;",
            "}",
            "",
            "int find_set(int v){ //findParentroot",
            "\tif(v==parent[v]) return v;",
            "\treturn parent[v]=find_set(parent[v]);",
            "}",
            "",
            "void union_sets(int a, int b){",
            "\ta=find_set(a);",
            "\tb=find_set(b);",
            "\tif(a!=b){",
            "\t\tif(siz[a]<siz[b])",
            "\t\t// if(rnk[a]<rnk[b])",
            "\t\t\tswap(a,b);",
            "\t\tparent[b]=a;",
            "\t\tsiz[a] += siz[b]; //when use siz remove next lines",
            "\t\t// if(rnk[a]==rnk[b])",
            "\t\t// rnk[a]++;",
            "\t}",
            "}",
            "",
            "//first use this loop to make set",
            "//for(int i=1;i<=n;i++){",
            "//\tmake_set(i);",
            "//}",
            "",
        ],
        "description": "dsu template"
    },
    "Segement finding because it takes time": {
        "prefix": "segmentize",
        "body": [
            " int win = 0;",
            "    int loss = 0;",
            "    vector<int> losses;",
            "    vector<int> wins;",
            "    for (int i = 0; i < n; i++)",
            "    {",
            "        if (s[i] == 'B')",
            "        {",
            "            win++;",
            "            if (loss > 0)",
            "            {",
            "                losses.push_back(loss);",
            "                loss = 0;",
            "            }",
            "        }",
            "        else",
            "        {",
            "            loss++;",
            "            if (win > 0)",
            "            {",
            "                wins.push_back(win);",
            "                win = 0;",
            "            }",
            "        }",
            "    }",
            "    if (win > 0)",
            "    {",
            "        wins.push_back(win);",
            "        win = 0;",
            "    }",
            "    if (loss > 0)",
            "    {",
            "        losses.push_back(loss);",
            "        loss = 0;",
            "    }",
            "    dbg(wins);",
            "    dbg(losses);",
            "    dbg(wins.size(), losses.size());"
        ],
        "description": "Segement finding because it takes time"
    },
    "GraphInput": {
        "prefix": "graph",
        "body": [
            "// adjacency list representation",
            "int n, m;",
            "cin >> n >> m;",
            "vector<vector<int>> g(n + 1);// n + 1 because nodes are numbered from [1.....n]",
            "int edges = m;//in most cases",
            "while (edges--)",
            "{",
            "    int u, v;",
            "    cin >> u >> v;",
            "    g[u].push_back(v);",
            "    g[v].push_back(u);",
            "}"
        ],
        "description": "GraphInput"
    },
    "fastPrimeCheck": {
        "prefix": "miller_rabin",
        "body": [
            "int exp(int x, int y, int M = 0)",
            "{",
            "    int v = 1;",
            "    if (M > int(0))",
            "    {",
            "        x = x % M;",
            "        while (y > 0)",
            "        {",
            "            if (y & 1)",
            "                v = (v * x) % M;",
            "            y = y >> 1;",
            "            x = (x * x) % M;",
            "        }",
            "        return v;",
            "    }",
            "    else",
            "    {",
            "        while (y > 0)",
            "        {",
            "            if (y & 1)",
            "                v = v * x;",
            "            y = y >> 1;",
            "            x = x * x;",
            "        }",
            "        return v;",
            "    }",
            "}",
            "// check for primes in n^(1/3) complexity",
            "bool miller_rabin(unsigned n)",
            "{",
            "    if (n < 2)",
            "        return false;",
            "",
            "    // Check small primes.",
            "    for (unsigned p : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})",
            "        if (n % p == 0)",
            "            return n == p;",
            "",
            "    int r = __builtin_ctz(n - 1);",
            "    unsigned d = (n - 1) >> r;",
            "",
            "    // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Testing_against_small_sets_of_bases",
            "    for (unsigned a : {2, 7, 61})",
            "    {",
            "        unsigned x = exp(a % n, d, n);",
            "",
            "        if (x <= 1 || x == n - 1)",
            "            continue;",
            "",
            "        for (int i = 0; i < r - 1 && x != n - 1; i++)",
            "            x = unsigned(uint64_t(x) * x % n);",
            "",
            "        if (x != n - 1)",
            "            return false;",
            "    }",
            "",
            "    return true;",
            "}"
        ],
        "description": "fastPrimeCheck"
    },
    "SparseTable": {
        "prefix": "sparsetable",
        "body": [
            "template <typename T>",
            "struct sparse_table",
            "{",
            "    using F = std::function<T(const T &, const T &)>;",
            "",
            "    int n;",
            "    std::vector<std::vector<T>> mat;",
            "    F f;",
            "    sparse_table() : n(), f() {}",
            "",
            "    template <typename U>",
            "    sparse_table(const U &arr, int n, F f) : n(n), f(f), mat((int)log2(n) + 1)",
            "    {",
            "        mat[0].resize(n);",
            "        for (int i = 0; i < n; i++)",
            "            mat[0][i] = T(arr[i]);",
            "        for (int j = 1; j < mat.size(); j++)",
            "        {",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i + (1 << j) <= n; i++)",
            "            {",
            "                mat[j][i] = f(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T query(int l, int r)",
            "    {",
            "        int j = 32 - __builtin_clz(r - l + 1) - 1;",
            "        return f(mat[j][l], mat[j][r + 1 - (1 << j)]);",
            "    }",
            "    /*****************/",
            "    // usage example",
            "    // sparse_table<int> st(a, n, [&](auto x, auto y){ return max(x, y); });",
            "    /*****************/",
            "    // can support indempotent function/properties --> min , max , sum , gcd , OR , bitwise&",
            "};"
        ],
        "description": "SparseTable"
    },
    "gcd and lcm": {
        "prefix": "gcdandlcm",
        "body": [
            "int gcd(int a, int b)",
            "{",
            "    return (a % b == 0) ? b : gcd(b, a % b);",
            "}",
            "int lcm(int a , int b){",
            "    return a * b / gcd(a, b);",
            "}"
        ],
        "description": "gcd and lcm"
    },
    "output_vector": {
        "prefix": "out_vector",
        "body": [
            "template<typename T_vector>",
            "void output_vector(const T_vector &v, bool add_one = false, int start = -1, int end = -1) {",
            "    if (start < 0) start = 0;",
            "    if (end < 0) end = int(v.size());",
            " ",
            "    for (int i = start; i < end; i++)",
            "        cout << v[i] + (add_one ? 1 : 0) << (i < end - 1 ? ' ' : '\\n');",
            "}"
        ],
        "description": "output_vector"
    },
    "pi value": {
        "prefix": "pi",
        "body": [
            "const long double PI = acos(-1);"
        ],
        "description": "pi value"
    },
    "Sieve using bitset with prime factor and totient fucntion feature": {
        "prefix": "sieve",
        "body": [
            "",
            "#define Sieve",
            "int _sieve_size;",
            "bitset<10000010> bs; // 10^7 + small extra bits should be enough for most prime-related problems",
            "vector<int> primes;  // compact list of primes in form of vector<int>",
            "void Eratosthenes(int upperbound)",
            "{                                 // create list of primes in [0 .. upperbound]",
            "    _sieve_size = upperbound + 1; // add 1 to include upperbound",
            "    bs.reset();",
            "    bs.flip(); // set all numbers to 1",
            "    bs.set(0, false);",
            "    bs.set(1, false); // except index 0 and 1",
            "    for (int i = 2; i <= _sieve_size; i++)",
            "        if (bs.test((size_t)i))",
            "        {",
            "            // cross out multiples of i starting from i * i!",
            "            for (int j = i * i; j <= _sieve_size; j += i)",
            "                bs.set((size_t)j, false);",
            "            primes.push_back((size_t)i); // also add this vector containing list of primes",
            "        }",
            "} // call this method in main method",
            "",
            "bool isPrime(int N)",
            "{ // a good enough deterministic prime tester",
            "    if (N < _sieve_size)",
            "        return bs.test(N); // O(1) for small primes",
            "    for (int i = 0; i < primes.size() - 1; i++)",
            "    {",
            "        if (N % primes[i] == 0)",
            "            return false;",
            "    }",
            "    return true; // it takes longer time if N is a large prime!",
            "} // Note: only work for N <= (last prime in vector<int> \"primes\")^2",
            "",
            "vector<int> primeFactors(int N)",
            "{",
            "    vector<int> factors;                 // vector<int> \"primes\" (generated by sieve) is optional",
            "    int PF_idx = 0, PF = primes[PF_idx]; // using PF = 2, 3, 4, ..., is also ok.",
            "    while (N != 1 && (PF * PF <= N))",
            "    { // stop at sqrt(N), but N can get smaller",
            "        while (N % PF == 0)",
            "        {",
            "            N /= PF;",
            "            factors.push_back(PF);",
            "        }                      // remove this PF",
            "        PF = primes[++PF_idx]; // only consider primes!",
            "    }",
            "    if (N != 1)",
            "        factors.push_back(N); // special case if N is actually a prime",
            "    return factors;",
            "}",
            "int EulerPhi(int N)",
            "{",
            "    vector<int> factors = primeFactors(N);",
            "    auto new_end = unique(factors.begin(), factors.end()); // get unique",
            "    int result = N;",
            "    for (auto i = factors.begin(); i != new_end; i++)",
            "        result = result - result / *i;",
            "    return result;",
            "}",
            "/**",
            "define this below in main!",
            "",
            "#ifdef Sieve",
            "    Eratosthenes(N);",
            "#endif",
            "**/",
            ""
        ],
        "description": "Sieve using bitset with prime factor and totient fucntion feature"
    },
    "Snippet with namspaces": {
        "prefix": "yesitsis",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "",
            "#define int int64_t",
            "#define sz(x) int((x).size())",
            "#define all(x) (x).begin(), (x).end()",
            "#define rall(x) (x).rbegin(), (x).rend()",
            "#define endl '\\n'",
            "",
            "template <typename T> void wmin(T &a, const T &b) { a = min(a, b); }",
            "template <typename T> void wmax(T &a, const T &b) { a = max(a, b); }",
            "",
            "namespace __input {",
            "    template <class T1, class T2> void re(pair<T1, T2> &p);",
            "    template <class T> void re(vector<T> &a);",
            "    template <class T, size_t SZ> void re(array<T, SZ> &a);",
            "",
            "    template <class T> void re(T &x) { cin >> x; }",
            "    void re(double &x) { string t; re(t); x = stod(t); }",
            "    template <class Arg, class... Args> void re(Arg &first, Args &...rest) { re(first); re(rest...); }",
            "",
            "    template <class T1, class T2> void re(pair<T1, T2> &p) { re(p.first, p.second); }",
            "    template <class T> void re(vector<T> &a) { for (auto &x : a) re(x); }",
            "    template <class T, size_t SZ> void re(array<T, SZ> &a) { for (auto &x : a) re(x); }",
            "}",
            "using namespace __input;",
            "",
            "namespace __output {",
            "    template <typename T> struct is_outputtable { template <typename C> static constexpr decltype(declval<ostream &>() << declval<const C &>(), bool()) test(int) { return true; } template <typename C> static constexpr bool test(...) { return false; } static constexpr bool value = test<T>(int()); };",
            "    template <class T, typename V = decltype(declval<const T &>().begin()), typename S = typename enable_if<!is_outputtable<T>::value, bool>::type> void pr(const T &x);",
            "",
            "    template <class T, typename V = decltype(declval<ostream &>() << declval<const T &>())> void pr(const T &x) { cout << x; }",
            "    template <class T1, class T2> void pr(const pair<T1, T2> &x);",
            "    template <class Arg, class... Args> void pr(const Arg &first, const Args &...rest) { pr(first); pr(rest...); }",
            "",
            "    template <class T, bool pretty = true> void prContain(const T &x) { if (pretty) pr(\"{\"); bool fst = 1; for (const auto &a : x) pr(!fst ? pretty ? \", \" : \" \" : \"\", a), fst = 0; if (pretty) pr(\"}\"); }",
            "",
            "    template <class T> void pc(const T &x) { prContain<T, false>(x); pr(\"\\n\"); }",
            "    template <class T1, class T2> void pr(const pair<T1, T2> &x) { pr(\"{\", x.first, \", \", x.second, \"}\"); }",
            "    template <class T, typename V, typename S> void pr(const T &x) { prContain(x); }",
            "",
            "    void ps() { pr(\"\\n\"); }",
            "    template <class Arg> void ps(const Arg &first) { pr(first); ps(); }",
            "    template <class Arg, class... Args> void ps(const Arg &first, const Args &...rest) { pr(first, \" \"); ps(rest...); }",
            "}",
            "using namespace __output;",
            "",
            "#define __pn(x) pr(#x, \" = \")",
            "#ifndef ONLINE_JUDGE",
            "#define dbg(...) pr(\"\\033[0;33m\"), __pn((__VA_ARGS__)), ps(__VA_ARGS__), pr(\"\\033[0m\"), cout << flush",
            "#else",
            "#define dbg(...)",
            "#endif",
            "",
            "namespace __algorithm {",
            "    template <typename T> void dedup(vector<T> &v) { sort(all(v)); v.erase(unique(all(v)), v.end()); }",
            "    template <typename T> typename vector<T>::const_iterator find(const vector<T> &v, const T &x) { auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end(); }",
            "    template <typename T> size_t index(const vector<T> &v, const T &x) { auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin(); }",
            "    template <typename I> struct _reversed_struct { I &v_; explicit _reversed_struct(I &v) : v_{v} {} typename I::reverse_iterator begin() const { return v_.rbegin(); } typename I::reverse_iterator end() const { return v_.rend(); } };",
            "    template <typename I> _reversed_struct<I> reversed(I &v) { return _reversed_struct<I>(v); }",
            "    template <typename I> struct _range_struct { const I first_, last_; explicit _range_struct(const I first, const I last) : first_{first}, last_{last} {} I begin() const { return first_; } I end() const { return last_; } };",
            "    template <typename I> _range_struct<I> range(const I first, const I last) { return _range_struct<I>(first, last); }",
            "}",
            "using namespace __algorithm;",
            "",
            "namespace __io {",
            "    void setIO() { ios_base::sync_with_stdio(0); cin.tie(0); cout << setprecision(15); }",
            "}",
            "using namespace __io;",
            "",
            "void solve(){",
            "    $0",
            "}",
            "signed main()",
            "{",
            "    setIO();",
            "    #ifdef Sieve",
            "    Eratosthenes(N);",
            "#endif",
            "    int T= 1;",
            "    ${1:}cin >> T;",
            "    for (int test = 1; test <= T; ++test)",
            "    {",
            "        solve();",
            "    }",
            "#ifndef ONLINE_JUDGE",
            "     cerr <<  \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";",
            "#endif",
            "    return 0;",
            "}"
        ],
        "description": "Snippet with namspaces"
    },
    "Modular Artithmetic": {
        "prefix": "modoperations",
        "body": [
            "namespace mod_operations {",
            "    int madd(int a, int b) {",
            "        return (a + b) % mod;",
            "    }",
            "    int msub(int a, int b) {",
            "        return (((a - b) % mod) + mod) % mod;",
            "    }",
            "    int mmul(int a, int b) {",
            "        return ((a % mod) * (b % mod)) % mod;",
            "    }",
            "    int mpow(int base, int exp) {",
            "        int res = 1;",
            "        while (exp) {",
            "            if (exp % 2 == 1){",
            "                res = (res * base) % mod;",
            "            }",
            "            exp >>= 1;",
            "            base = (base * base) % mod;",
            "        }",
            "        return res;",
            "    }",
            "    int minv(int base) {",
            "        return mpow(base, mod - 2);",
            "    }",
            "    int mdiv(int a, int b) {",
            "        return mmul(a, minv(b));",
            "    }",
            "",
            "    const int FACTORIAL_SIZE = 1.1e6;",
            "    int fact[FACTORIAL_SIZE], ifact[FACTORIAL_SIZE];",
            "    bool __factorials_generated__ = 0;",
            "    void gen_factorial(int n) {",
            "        __factorials_generated__ = 1;",
            "        fact[0] = fact[1] = ifact[0] = ifact[1] = 1;",
            "                                                     ",
            "        for (int i = 2; i <= n; i++) {",
            "            fact[i] = (i * fact[i - 1]) % mod;",
            "        }",
            "        ifact[n] = minv(fact[n]);",
            "        for (int i = n - 1; i >= 2; i--) {",
            "            ifact[i] = ((i + 1) * ifact[i + 1]) % mod;",
            "        }",
            "    }",
            "    int ncr(int n, int k) {",
            "        if (!__factorials_generated__) {",
            "            cerr << \"Call gen_factorial you dope\" << endl;",
            "            exit(1);",
            "        }",
            "        if (k < 0 || n < k) return 0;",
            "        int den = (ifact[k] * ifact[n - k]) % mod;",
            "        return (den * fact[n]) % mod;",
            "    }",
            "}",
            "",
            "using namespace mod_operations;"
        ],
        "description": "Modular Artithmetic"
    },
    "adjacency list dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "int n , m;",
            "cin >> n >> m;",
            "vector<vector<P>>g(n  + 1);",
            "for(int i = 0; i < m; i++)",
            "{",
            "    int u, v;",
            "    cin >> u >> v;",
            "    g[u].push_back({v,0});",
            "    g[v].push_back({u,0});",
            "    ",
            "}",
            "auto dijkstra = [&](int src, int n, vector<int> &p){",
            "    /**",
            "     *  set based implementation",
            "     *  complexity O((n + m)logn)",
            "     */",
            "    vector<int> d(n + 1, inf);",
            "    set<pair<int, int>> q;",
            "    q.insert({0, src});",
            "    d[src] = 0;",
            "    while (!q.empty())",
            "    {",
            "        int v = q.begin()->second;",
            "        // dbg(v);",
            "        q.erase(q.begin());",
            "        for (auto edge : g[v]) {",
            "            int to = edge.first;",
            "            int len = edge.second;",
            "            if (d[v] + len < d[to]) {",
            "                q.erase({d[to], to});",
            "                d[to] = d[v] + len;",
            "                p[to] = v;",
            "                q.insert({d[to], to});",
            "            }",
            "        }",
            "    }",
            "    return d;",
            "    //copy this ! ",
            "};",
            "vector<int> par(n + 1, -1);",
            "vector<int> dd = dijkstra(1, n, par);"
        ],
        "description": "adjacency list dijkstra"
    }
}